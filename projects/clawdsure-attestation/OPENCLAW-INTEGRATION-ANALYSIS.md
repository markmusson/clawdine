# OpenClaw Attestation Integration Analysis
*Generated by Codex analysis of openclaw/openclaw — Feb 18, 2026*

---

## Best Insertion Point and Why

**Recommended path:** Core security module with internal hook orchestration, surfaced via an internal/optional plugin bridge (not a standard skill).

The attestation chain needs protected handling of hashes, keys, and integrity policy — that belongs in trusted runtime/security boundaries rather than untrusted skill space. VISION.md says features should be plugins by default, but allows stronger guarantees in core for security controls. Attestation is foundational trust infrastructure, so keeping signer/chain logic in core is justified.

---

## What Already Exists to Plug Into

**Core hook/plugin backbone already emits stable lifecycle events:**
- Session boundaries (`session_start`, `session_end`) — `src/auto-reply/reply/session.ts`
- Message pipeline (`message_received`, `message_sending`, `message_sent`) — dispatch/outbound code
- Agent execution lifecycle (`agent:bootstrap`, `before_model_resolve`, `before_prompt_build`) and command/session reset points

**Security/audit foundations already present:**
- `src/security/audit.ts`
- `src/security/audit-extra.ts`
- `src/security/audit-extra.sync.ts`
- Existing checks already include plugin safety, hook integrity, gateway/firewall posture, and config surface checks

**Config hashing utilities already exist:**
- `src/config/io.ts` — `hashConfigRaw`
- `src/agents/sandbox/config-hash.ts` — deterministic hashing style

**Existing persisted event pattern** via bundled hooks (`src/hooks/bundled/command-logger/handler.ts`) suggests durable chain output style is acceptable.

**Internal and plugin hook registration/routing:**
- `src/hooks/internal-hooks.ts`
- `src/hooks/loader.ts`
- `src/plugins/types.ts`
- `src/plugins/registry.ts`
- `src/plugins/hook-runner-global.ts`

---

## What Needs to Be Built

1. **Deterministic collection + canonicalization** — machine fingerprint, skills manifest/hash, firewall state, config snapshot
2. **Daily chain composer** — current-state hash, prev-hash chaining, tamper-evident serialization
3. **ECDSA key lifecycle** — key storage, rotation, revocation, signing/verification, local trust roots
4. **IPFS pinning adaptor** — chain anchors and retrieval proofs
5. **Scheduling and trigger strategy** — startup + daily cadence + optional change-triggered recompute
6. **Recovery and alert flow** — when verification fails (chain break, key mismatch, missing prior anchor)
7. **Minimal observer plugin contract** — sinks/reporting to avoid forcing all deployments to one backend

---

## Core vs Plugin Recommendation (VISION.md aligned)

| What | Where |
|------|-------|
| Chain integrity calculation | **Core** |
| Signature/verification logic | **Core** |
| Key custody | **Core** |
| Enforcement action on violation | **Core** |
| IPFS providers | **Plugin/extension** |
| SIEM exporters | **Plugin/extension** |
| Custom verifier backends | **Plugin/extension** |
| Regular skill placement | **Never** — wrong security boundary |

---

## Strategic Note

The analysis confirms what we already built in bash (ClawdSure skill) is architecturally correct — we just built it in the wrong layer. The right home is `src/security/` extending the existing audit modules, not a user-facing skill. The hook infrastructure and config hashing primitives are already there. We're not asking for something new — we're asking to wire existing primitives into a chain and give them a signer.

This is a strong PR pitch: low conceptual lift (primitives exist), high security value, VISION.md-defensible as core security infrastructure.
